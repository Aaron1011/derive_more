<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>What #[derive(Mul)] generates</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
<link rel="stylesheet" type="text/css" href="../main.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <style>
.content a {
  color: #3873AD;
}
.content .section-header a,
.content .search-results a {
  color: #000;
}
</style>

<nav class="sidebar">

  <p class='location'><a href='index.html'>derive_more</a></p>
    <script defer src="../sidebar-items.js"></script>
</nav>

<nav class="sub">
		<form class="search-form js-only">
				<div class="search-container">
						<input class="search-input" name="search"
									 autocomplete="off"
									 placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
									 type="search">
				</div>
		</form>
</nav>

<section id='main' class="content fn">




    <h1 class="title">What #[derive(Mul)] generates</h1>
    <nav id="TOC"><ul>
<li><a href="#tuple-structs">1 Tuple structs</a><ul></ul></li>
<li><a href="#regular-structs">2 Regular structs</a><ul></ul></li>
<li><a href="#enums">3 Enums</a><ul></ul></li></ul></nav><p>Deriving <code>Mul</code> is quite different from deriving <code>Add</code>. It is not used to
multiply two structs together. Instead it will normally multipy a struct, which
can have multiple fields, with a single primitive type (e.g. a <code>u64</code>). A new
struct is then created with all the fields from the previous struct multiplied
by this other value.</p>

<p>A simple way of explaining the reasoning behind this difference between <code>Add</code>
and <code>Mul</code> deriving, is looking at arithmetic on meters.
One meter can be added to one meter, to get two meters. Also, one meter times
two would be two meters, but one meter times one meter would be one square meter.
As this second case clearly requires more knowledge about the meaning of the
type in question deriving for this is not implemented.</p>

<h1 id='tuple-structs' class='section-header'><a href='#tuple-structs'>1 Tuple structs</a></h1>
<p>When deriving for a tuple struct with a single field (i.e. a newtype) like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>From</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>MyInt</span>(<span class='ident'>i32</span>)</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>MyInt</span>
    <span class='kw'>where</span> <span class='ident'>T</span>: ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>i32</span><span class='op'>&gt;</span>
{
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>MyInt</span>;
    <span class='kw'>fn</span> <span class='ident'>mul</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>MyInt</span> {
        <span class='ident'>MyInt</span>(<span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='number'>0</span>))
    }
}</pre>

<p>The behaviour is slightly different for multiple fields, since the right hand
side of the multiplication now needs the <code>Copy</code> trait.
For instance when deriving for a tuple struct with two fields like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Mul</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>MyInts</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>)</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>MyInts</span>
    <span class='kw'>where</span> <span class='ident'>T</span>: ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>+</span> ::<span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>Copy</span>
{
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>MyInts</span>;
    <span class='kw'>fn</span> <span class='ident'>mul</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>MyInts</span> {
        <span class='ident'>MyInts</span>(<span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='number'>0</span>), <span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='number'>1</span>))
    }
}</pre>

<p>The behaviour is similar with more or less fields.</p>

<h1 id='regular-structs' class='section-header'><a href='#regular-structs'>2 Regular structs</a></h1>
<p>When deriving <code>Mul</code> for a regular struct with a single field like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Mul</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Point1D</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
}</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Point1D</span>
    <span class='kw'>where</span> <span class='ident'>T</span>: ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>i32</span><span class='op'>&gt;</span>
{
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Point1D</span>;
    <span class='kw'>fn</span> <span class='ident'>mul</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Point1D</span> {
        <span class='ident'>Point1D</span> { <span class='ident'>x</span>: <span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='ident'>x</span>) }
    }
}</pre>

<p>The behaviour is again slightly different when deriving for a struct with multiple
fields, because it still needs the <code>Copy</code> as well.
For instance when deriving for a tuple struct with two fields like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Mul</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Point2D</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>T</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>Point2D</span>
    <span class='kw'>where</span> <span class='ident'>T</span>: ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Mul</span><span class='op'>&lt;</span><span class='ident'>i32</span>, <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>i32</span><span class='op'>&gt;</span> <span class='op'>+</span> ::<span class='ident'>std</span>::<span class='ident'>marker</span>::<span class='ident'>Copy</span>
{
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Point2D</span>;
    <span class='kw'>fn</span> <span class='ident'>mul</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>T</span>) <span class='op'>-&gt;</span> <span class='ident'>Point2D</span> {
        <span class='ident'>Point2D</span> {
            <span class='ident'>x</span>: <span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='ident'>x</span>),
            <span class='ident'>y</span>: <span class='ident'>rhs</span>.<span class='ident'>mul</span>(<span class='self'>self</span>.<span class='ident'>y</span>),
        }
    }
}</pre>

<h1 id='enums' class='section-header'><a href='#enums'>3 Enums</a></h1>
<p>Deriving <code>Mul</code> for enums is not (yet) supported.
Although it shouldn&#39;t be impossible no effort has been put into this yet.</p>

    </section>
<section id='search' class="content hidden"></section>

<section class="footer"></section>

<aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>
<p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>



    <script>
        window.rootPath = "../../";
        window.currentCrate = "derive_more";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>


</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>What #[derive(Add)] generates</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
<link rel="stylesheet" type="text/css" href="../main.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <style>
.content a {
  color: #3873AD;
}
.content .section-header a,
.content .search-results a {
  color: #000;
}
</style>

<nav class="sidebar">

  <p class='location'><a href='index.html'>derive_more</a></p>
    <script defer src="../sidebar-items.js"></script>
</nav>

<nav class="sub">
		<form class="search-form js-only">
				<div class="search-container">
						<input class="search-input" name="search"
									 autocomplete="off"
									 placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
									 type="search">
				</div>
		</form>
</nav>

<section id='main' class="content fn">




    <h1 class="title">What #[derive(Add)] generates</h1>
    <nav id="TOC"><ul>
<li><a href="#tuple-structs">1 Tuple structs</a><ul></ul></li>
<li><a href="#regular-structs">2 Regular structs</a><ul></ul></li>
<li><a href="#enums">3 Enums</a><ul></ul></li></ul></nav><p>The derived <code>Add</code> implementation will allow two structs from the same type to be
added together. This done by adding their respective fields together and
creating a new struct with those values.
For enums each variant can be added in a similar way to another instance of that
same variant. There&#39;s one big difference however, it returns a
<code>Result&lt;EnumType&gt;</code>, because an error is returned when to different variants are
added together.</p>

<h1 id='tuple-structs' class='section-header'><a href='#tuple-structs'>1 Tuple structs</a></h1>
<p>When deriving <code>Add</code> for a tuple struct with two fields like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Add</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>MyInts</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>)</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>MyInts</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>MyInts</span>;
    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>MyInts</span>) <span class='op'>-&gt;</span> <span class='ident'>MyInts</span> {
        <span class='ident'>MyInts</span>(<span class='self'>self</span>.<span class='number'>0</span>.<span class='ident'>add</span>(<span class='ident'>rhs</span>.<span class='number'>0</span>), <span class='self'>self</span>.<span class='number'>1</span>.<span class='ident'>add</span>(<span class='ident'>rhs</span>.<span class='number'>1</span>))
    }
}</pre>

<p>The behaviour is similar with more or less fields.</p>

<h1 id='regular-structs' class='section-header'><a href='#regular-structs'>2 Regular structs</a></h1>
<p>When deriving <code>Add</code> for a regular struct with two fields like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Add</span>)]</span>
<span class='kw'>struct</span> <span class='ident'>Point2D</span> {
    <span class='ident'>x</span>: <span class='ident'>i32</span>,
    <span class='ident'>y</span>: <span class='ident'>i32</span>,
}</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>Point2D</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='ident'>Point2D</span>;
    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>Point2D</span>) <span class='op'>-&gt;</span> <span class='ident'>Point2D</span> {
        <span class='ident'>Point2D</span> {
            <span class='ident'>x</span>: <span class='self'>self</span>.<span class='ident'>x</span>.<span class='ident'>add</span>(<span class='ident'>rhs</span>.<span class='ident'>x</span>),
            <span class='ident'>y</span>: <span class='self'>self</span>.<span class='ident'>y</span>.<span class='ident'>add</span>(<span class='ident'>rhs</span>.<span class='ident'>y</span>),
        }
    }
}</pre>

<p>The behaviour is similar for more or less fields.</p>

<h1 id='enums' class='section-header'><a href='#enums'>3 Enums</a></h1>
<p>There&#39;s a big difference between the code that is generated for the two struct
types and the one that is generated for enums. The code for enums returns
<code>Result&lt;EnumType&gt;</code> instead of an <code>EnumType</code> itself. This is because adding an
enum to another enum is only possible if both are the same variant. This makes
the generated code much more complex as well, because this check needs to be
done. For instance when deriving <code>Add</code> for an enum like this:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Add</span>)]</span>
<span class='kw'>enum</span> <span class='ident'>MixedInts</span> {
    <span class='ident'>SmallInt</span>(<span class='ident'>i32</span>),
    <span class='ident'>BigInt</span>(<span class='ident'>i64</span>),
    <span class='ident'>TwoSmallInts</span>(<span class='ident'>i32</span>, <span class='ident'>i32</span>),
    <span class='ident'>NamedSmallInts</span> { <span class='ident'>x</span>: <span class='ident'>i32</span>, <span class='ident'>y</span>: <span class='ident'>i32</span> },
    <span class='ident'>UnsignedOne</span>(<span class='ident'>u32</span>),
    <span class='ident'>UnsignedTwo</span>(<span class='ident'>u32</span>),
    <span class='ident'>Unit</span>,
}</pre>

<p>Code like this will be generated:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> ::<span class='ident'>std</span>::<span class='ident'>ops</span>::<span class='ident'>Add</span> <span class='kw'>for</span> <span class='ident'>MixedInts</span> {
    <span class='kw'>type</span> <span class='ident'>Output</span> <span class='op'>=</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>MixedInts</span>, <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span>;
    <span class='kw'>fn</span> <span class='ident'>add</span>(<span class='self'>self</span>, <span class='ident'>rhs</span>: <span class='ident'>MixedInts</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span><span class='ident'>MixedInts</span>, <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span><span class='op'>&gt;</span> {
        <span class='kw'>match</span> (<span class='self'>self</span>, <span class='ident'>rhs</span>) {
            (<span class='ident'>MixedInts</span>::<span class='ident'>SmallInt</span>(<span class='ident'>__l_0</span>), <span class='ident'>MixedInts</span>::<span class='ident'>SmallInt</span>(<span class='ident'>__r_0</span>)) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>SmallInt</span>(<span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>)))
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>BigInt</span>(<span class='ident'>__l_0</span>), <span class='ident'>MixedInts</span>::<span class='ident'>BigInt</span>(<span class='ident'>__r_0</span>)) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>BigInt</span>(<span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>)))
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>TwoSmallInts</span>(<span class='ident'>__l_0</span>, <span class='ident'>__l_1</span>), <span class='ident'>MixedInts</span>::<span class='ident'>TwoSmallInts</span>(<span class='ident'>__r_0</span>, <span class='ident'>__r_1</span>)) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>TwoSmallInts</span>(<span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>), <span class='ident'>__l_1</span>.<span class='ident'>add</span>(<span class='ident'>__r_1</span>)))
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>NamedSmallInts</span> { <span class='ident'>x</span>: <span class='ident'>__l_0</span>, <span class='ident'>y</span>: <span class='ident'>__l_1</span> },
             <span class='ident'>MixedInts</span>::<span class='ident'>NamedSmallInts</span> { <span class='ident'>x</span>: <span class='ident'>__r_0</span>, <span class='ident'>y</span>: <span class='ident'>__r_1</span> }) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>NamedSmallInts</span> {
                    <span class='ident'>x</span>: <span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>),
                    <span class='ident'>y</span>: <span class='ident'>__l_1</span>.<span class='ident'>add</span>(<span class='ident'>__r_1</span>),
                })
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>UnsignedOne</span>(<span class='ident'>__l_0</span>), <span class='ident'>MixedInts</span>::<span class='ident'>UnsignedOne</span>(<span class='ident'>__r_0</span>)) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>UnsignedOne</span>(<span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>)))
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>UnsignedTwo</span>(<span class='ident'>__l_0</span>), <span class='ident'>MixedInts</span>::<span class='ident'>UnsignedTwo</span>(<span class='ident'>__r_0</span>)) <span class='op'>=&gt;</span> {
                <span class='prelude-val'>Ok</span>(<span class='ident'>MixedInts</span>::<span class='ident'>UnsignedTwo</span>(<span class='ident'>__l_0</span>.<span class='ident'>add</span>(<span class='ident'>__r_0</span>)))
            }
            (<span class='ident'>MixedInts</span>::<span class='ident'>Unit</span>, <span class='ident'>MixedInts</span>::<span class='ident'>Unit</span>) <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='string'>&quot;Cannot add() unit variants&quot;</span>),
            _ <span class='op'>=&gt;</span> <span class='prelude-val'>Err</span>(<span class='string'>&quot;Trying to add mismatched enum variants&quot;</span>),
        }
    }
}</pre>

<p>Also note the Unit type that throws an error when adding it to itself.</p>

    </section>
<section id='search' class="content hidden"></section>

<section class="footer"></section>

<aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>
<p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>



    <script>
        window.rootPath = "../../";
        window.currentCrate = "derive_more";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>


</body>
</html>